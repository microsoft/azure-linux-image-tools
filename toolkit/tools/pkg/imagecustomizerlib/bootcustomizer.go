// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

package imagecustomizerlib

import (
	"errors"
	"fmt"
	"io/fs"
	"path/filepath"
	"strings"

	"github.com/microsoft/azure-linux-image-tools/toolkit/tools/imagecustomizerapi"
	"github.com/microsoft/azure-linux-image-tools/toolkit/tools/imagegen/installutils"
	"github.com/microsoft/azure-linux-image-tools/toolkit/tools/internal/grub"
	"github.com/microsoft/azure-linux-image-tools/toolkit/tools/internal/safechroot"
)

var (
	// Boot customization errors
	ErrBootGrubMkconfigGeneration        = NewImageCustomizerError("Boot:GrubMkconfigGeneration", "failed to generate grub.cfg via grub2-mkconfig")
	ErrBootNoConfigFound                 = NewImageCustomizerError("Boot:NoConfigFound", "no boot configuration found: grub.cfg does not exist and no UKI files found")
	ErrBootUkiPassthroughCmdlineModified = NewImageCustomizerError("Boot:UkiPassthroughCmdlineModified",
		"cannot modify kernel command-line in UKI passthrough mode: use 'mode: create' to customize kernel cmdline")
)

// bootConfigType represents the type of boot configuration used by the image.
type bootConfigType string

const (
	// bootConfigTypeGrubMkconfig indicates the image uses grub-mkconfig to generate grub.cfg.
	bootConfigTypeGrubMkconfig bootConfigType = "grub-mkconfig"
	// bootConfigTypeGrubLegacy indicates the image uses a manually maintained grub.cfg.
	bootConfigTypeGrubLegacy bootConfigType = "grub-legacy"
	// bootConfigTypeUki indicates the image uses UKI without grub.cfg.
	bootConfigTypeUki bootConfigType = "uki"
)

type BootCustomizer struct {
	// The contents of the /boot/grub2/grub.cfg file.
	grubCfgContent string

	// The contents of the /etc/default/grub file.
	defaultGrubFileContent string

	// The type of boot configuration used by the image.
	bootConfigType bootConfigType

	// The UKI mode when boot type is UKI (optional).
	ukiMode imagecustomizerapi.UkiMode

	// The path to the UKI kernel info file (for modify mode).
	ukiKernelInfoPath string
}

func NewBootCustomizer(imageChroot safechroot.ChrootInterface, uki *imagecustomizerapi.Uki, buildDir string) (*BootCustomizer, error) {
	grubCfgContent, err := ReadGrub2ConfigFile(imageChroot)
	if err != nil && !errors.Is(err, fs.ErrNotExist) {
		return nil, err
	}

	defaultGrubFileContent, err := readDefaultGrubFile(imageChroot)
	if err != nil && !errors.Is(err, fs.ErrNotExist) {
		return nil, err
	}

	// Determine boot configuration type
	bootConfigType, err := determineBootConfigType(grubCfgContent, imageChroot)
	if err != nil {
		return nil, err
	}

	ukiMode := imagecustomizerapi.UkiModeUnspecified
	ukiKernelInfoPath := ""
	if uki != nil {
		ukiMode = uki.Mode
		if ukiMode == imagecustomizerapi.UkiModeModify {
			ukiKernelInfoPath = filepath.Join(buildDir, UkiBuildDir, UkiKernelInfoJson)
		}
	}

	b := &BootCustomizer{
		grubCfgContent:         grubCfgContent,
		defaultGrubFileContent: defaultGrubFileContent,
		bootConfigType:         bootConfigType,
		ukiMode:                ukiMode,
		ukiKernelInfoPath:      ukiKernelInfoPath,
	}
	return b, nil
}

func determineBootConfigType(grubCfgContent string, imageChroot safechroot.ChrootInterface) (bootConfigType, error) {
	// If grub.cfg doesn't exist, check for UKI
	if grubCfgContent == "" {
		hasUkis, err := baseImageHasUkis(imageChroot.(*safechroot.Chroot))
		if err == nil && hasUkis {
			// UKI images without grub.cfg are in passthrough mode (grub.cfg not regenerated)
			// For UKI create mode, grub.cfg is regenerated during kernel extraction, so it would exist
			return bootConfigTypeUki, nil
		}
		// No grub.cfg and no UKIs - this is an error
		return "", ErrBootNoConfigFound
	}

	// If grub.cfg exists, check if it's generated by grub-mkconfig
	if isGrubMkconfigConfig(grubCfgContent) {
		return bootConfigTypeGrubMkconfig, nil
	}

	return bootConfigTypeGrubLegacy, nil
}

// Inserts new kernel command-line args into the grub config file.
func (b *BootCustomizer) AddKernelCommandLine(extraCommandLine []string) error {
	if len(extraCommandLine) <= 0 {
		return nil
	}

	combinedArgs := GrubArgsToString(extraCommandLine)

	switch b.bootConfigType {
	case bootConfigTypeGrubMkconfig:
		defaultGrubFileContent, err := addExtraCommandLineToDefaultGrubFile(b.defaultGrubFileContent, combinedArgs)
		if err != nil {
			return err
		}

		b.defaultGrubFileContent = defaultGrubFileContent

	case bootConfigTypeGrubLegacy:
		// Add the args directly to the /boot/grub2/grub.cfg file.
		grubCfgContent, err := appendKernelCommandLineArgsAll(b.grubCfgContent, combinedArgs)
		if err != nil {
			return err
		}

		b.grubCfgContent = grubCfgContent

	case bootConfigTypeUki:
		// UKI passthrough mode: preserve existing UKI boot configuration.
		// Cmdline args cannot be modified in passthrough mode.
		if b.ukiMode != imagecustomizerapi.UkiModeModify {
			return ErrBootUkiPassthroughCmdlineModified
		}
		// For modify mode, append args to the UKI cmdline file.
		err := b.appendToUkiCmdlineFile(combinedArgs)
		if err != nil {
			return err
		}
	}

	return nil
}

// getSELinuxModeFromCmdline gets the image's configured SELinux mode from kernel command-line.
// Returns (mode, found, error) where:
//   - mode: The detected SELinux mode (or SELinuxModeDefault if not found)
//   - found: true if cmdline exists and was successfully parsed
//   - error: Any error encountered during parsing
func (b *BootCustomizer) getSELinuxModeFromCmdline(buildDir string, imageChroot safechroot.ChrootInterface) (imagecustomizerapi.SELinuxMode, bool, error) {
	var err error
	var args []grubConfigLinuxArg

	// Get the SELinux kernel command-line args.
	switch b.bootConfigType {
	case bootConfigTypeGrubMkconfig:
		// Check both GRUB_CMDLINE_LINUX and GRUB_CMDLINE_LINUX_DEFAULT variables
		// and merge arguments from both if they exist
		args, err = GetDefaultGrubFileLinuxArgsFromMultipleVars(b.defaultGrubFileContent)
		if err != nil {
			return imagecustomizerapi.SELinuxModeDefault, false, fmt.Errorf("failed to find SELinux args in grub file (%s):\n%w", installutils.GrubDefFile, err)
		}

	case bootConfigTypeGrubLegacy:
		// Detect if this is Ubuntu/Debian (allows multiple kernel entries)
		allowMultipleKernels := false
		if imageChroot != nil {
			allowMultipleKernels = isPackageInstalledDpkg(imageChroot, "dpkg")
		}
		args, _, err = getLinuxCommandLineArgs(b.grubCfgContent, allowMultipleKernels)
		if err != nil {
			return imagecustomizerapi.SELinuxModeDefault, false,
				fmt.Errorf("failed to parse SELinux args from grub file (%s):\n%w", installutils.GrubCfgFile, err)
		}

	case bootConfigTypeUki:
		espDir := filepath.Join(imageChroot.RootDir(), EspDir)

		kernelToArgs, err := extractKernelCmdlineFromUkiEfis(espDir, buildDir)
		if err != nil {
			return imagecustomizerapi.SELinuxModeDefault, false, err
		}

		args, err = parseFirstCmdlineFromUkiMap(kernelToArgs)
		if err != nil {
			return imagecustomizerapi.SELinuxModeDefault, false, err
		}
	}

	// Get the SELinux mode from the kernel command-line args.
	selinuxMode, err := getSELinuxModeFromLinuxArgs(args)
	if err != nil {
		return imagecustomizerapi.SELinuxModeDefault, false, err
	}

	return selinuxMode, true, nil
}

func (b *BootCustomizer) GetSELinuxMode(buildDir string, imageChroot safechroot.ChrootInterface) (imagecustomizerapi.SELinuxMode, error) {
	// Try to get the SELinux mode from kernel command-line (grub or UKI).
	selinuxMode, found, err := b.getSELinuxModeFromCmdline(buildDir, imageChroot)
	if err != nil {
		return imagecustomizerapi.SELinuxModeDefault, err
	}
	if found && selinuxMode != imagecustomizerapi.SELinuxModeDefault {
		return selinuxMode, nil
	}

	// Fallback: Get the SELinux mode from the /etc/selinux/config file.
	selinuxMode, err = getSELinuxModeFromConfigFile(imageChroot)
	if err != nil {
		return imagecustomizerapi.SELinuxModeDefault, err
	}

	return selinuxMode, nil
}

// Update the image's SELinux kernel command-line args.
func (b *BootCustomizer) UpdateSELinuxCommandLine(selinuxMode imagecustomizerapi.SELinuxMode) error {
	newSELinuxArgs, err := selinuxModeToArgs(selinuxMode)
	if err != nil {
		return err
	}

	err = b.UpdateKernelCommandLineArgs(defaultGrubFileVarNameCmdlineForSELinux, selinuxArgNames, newSELinuxArgs)
	if err != nil {
		return err
	}

	return nil
}

// Update the image's SELinux kernel command-line args for OSModifier.
func (b *BootCustomizer) UpdateSELinuxCommandLineForEMU(selinuxMode imagecustomizerapi.SELinuxMode) error {
	newSELinuxArgs, err := selinuxModeToArgsWithPermissiveFlag(selinuxMode)
	if err != nil {
		return err
	}

	err = b.UpdateKernelCommandLineArgs(defaultGrubFileVarNameCmdlineForSELinux, selinuxArgNames, newSELinuxArgs)
	if err != nil {
		return err
	}

	return nil
}

func (b *BootCustomizer) UpdateKernelCommandLineArgs(defaultGrubFileVarName defaultGrubFileVarName,
	argsToRemove []string, newArgs []string,
) error {
	switch b.bootConfigType {
	case bootConfigTypeGrubMkconfig:
		defaultGrubFileContent, err := updateDefaultGrubFileKernelCommandLineArgs(b.defaultGrubFileContent,
			defaultGrubFileVarName, argsToRemove, newArgs)
		if err != nil {
			return err
		}

		b.defaultGrubFileContent = defaultGrubFileContent

	case bootConfigTypeGrubLegacy:
		grubCfgContent, err := updateKernelCommandLineArgsAll(b.grubCfgContent, argsToRemove, newArgs)
		if err != nil {
			return err
		}

		b.grubCfgContent = grubCfgContent

	case bootConfigTypeUki:
		// UKI passthrough mode: preserve existing UKI boot configuration.
		// Cmdline args cannot be modified in passthrough mode.
		if b.ukiMode != imagecustomizerapi.UkiModeModify {
			return ErrBootUkiPassthroughCmdlineModified
		}
		// For modify mode, update the UKI cmdline file.
		err := b.updateUkiCmdlineFile(argsToRemove, newArgs)
		if err != nil {
			return err
		}
	}

	return nil
}

// Makes changes to the /etc/default/grub file that are needed/useful for enabling verity.
func (b *BootCustomizer) PrepareForVerity() error {
	switch b.bootConfigType {
	case bootConfigTypeGrubMkconfig:
		// Force root command-line arg to be referenced by /dev path instead of by UUID.
		defaultGrubFileContent, err := UpdateDefaultGrubFileVariable(b.defaultGrubFileContent, "GRUB_DISABLE_UUID",
			"true")
		if err != nil {
			return err
		}

		// For rootfs verity, the root device will always be "/dev/mapper/root"
		rootDevicePath := imagecustomizerapi.VerityRootDevicePath
		defaultGrubFileContent, err = UpdateDefaultGrubFileVariable(defaultGrubFileContent, "GRUB_DEVICE",
			rootDevicePath)
		if err != nil {
			return err
		}

		b.defaultGrubFileContent = defaultGrubFileContent

	case bootConfigTypeGrubLegacy:
		// Legacy grub configurations don't need special preparation for verity.
		// The verity args will be directly added to grub.cfg.

	case bootConfigTypeUki:
		// UKI passthrough mode: preserve existing UKI boot configuration.
		// Verity configuration is embedded in UKI files during UKI regeneration.
	}

	return nil
}

func (b *BootCustomizer) WriteToFile(imageChroot safechroot.ChrootInterface) error {
	switch b.bootConfigType {
	case bootConfigTypeGrubMkconfig:
		// Update /etc/default/grub file.
		err := WriteDefaultGrubFile(b.defaultGrubFileContent, imageChroot)
		if err != nil {
			return err
		}
		// Update /boot/grub2/grub.cfg file.
		err = installutils.CallGrubMkconfig(imageChroot)
		if err != nil {
			return fmt.Errorf("%w:\n%w", ErrBootGrubMkconfigGeneration, err)
		}

	case bootConfigTypeGrubLegacy:
		// Update grub.cfg file.
		err := writeGrub2ConfigFile(b.grubCfgContent, imageChroot)
		if err != nil {
			return err
		}

	case bootConfigTypeUki:
		// UKI passthrough mode: preserve existing UKI boot configuration.
		// UKI files are managed by UKI-specific customization logic, not through grub.
		// Future: May need to update boot loader configuration when native UKI boot support is added.
	}

	return nil
}

func (b *BootCustomizer) SetRootDevice(rootDevice string) error {
	updatedGrubFileContent, err := UpdateDefaultGrubFileVariable(b.defaultGrubFileContent, "GRUB_DEVICE", rootDevice)
	if err != nil {
		return err
	}

	b.defaultGrubFileContent = updatedGrubFileContent

	return nil
}

// appendToUkiCmdlineFile appends kernel arguments to all kernels in the UKI kernel info file.
func (b *BootCustomizer) appendToUkiCmdlineFile(args string) error {
	if b.ukiKernelInfoPath == "" {
		return fmt.Errorf("UKI kernel info file path not set")
	}

	kernelInfo, err := readUkiKernelInfoFile(b.ukiKernelInfoPath)
	if err != nil {
		return fmt.Errorf("failed to read UKI kernel info file:\n%w", err)
	}

	// Append args to each kernel's cmdline
	for kernel, info := range kernelInfo {
		updatedCmdline := strings.TrimSpace(info.Cmdline) + " " + args
		kernelInfo[kernel] = UkiKernelInfo{
			Cmdline:   updatedCmdline,
			Initramfs: info.Initramfs,
		}
	}

	err = writeUkiKernelInfoFile(b.ukiKernelInfoPath, kernelInfo)
	if err != nil {
		return fmt.Errorf("failed to write UKI kernel info file:\n%w", err)
	}

	return nil
}

// updateUkiCmdlineFile updates kernel arguments for all kernels in the UKI kernel info file.
func (b *BootCustomizer) updateUkiCmdlineFile(argsToRemove []string, newArgs []string) error {
	if b.ukiKernelInfoPath == "" {
		return fmt.Errorf("UKI kernel info file path not set")
	}

	kernelInfo, err := readUkiKernelInfoFile(b.ukiKernelInfoPath)
	if err != nil {
		return fmt.Errorf("failed to read UKI kernel info file:\n%w", err)
	}

	// Update each kernel's cmdline
	for kernel, info := range kernelInfo {
		currentCmdline := strings.TrimSpace(info.Cmdline)
		tokens, err := grub.TokenizeConfig(currentCmdline)
		if err != nil {
			return fmt.Errorf("failed to tokenize UKI cmdline for kernel (%s):\n%w", kernel, err)
		}
		currentArgs, err := ParseCommandLineArgs(tokens)
		if err != nil {
			return fmt.Errorf("failed to parse UKI cmdline for kernel (%s):\n%w", kernel, err)
		}

		// Remove args that match any of the argsToRemove prefixes and build string array
		var argStrings []string
		for _, arg := range currentArgs {
			shouldRemove := false
			for _, removePrefix := range argsToRemove {
				if arg.Name == removePrefix {
					shouldRemove = true
					break
				}
			}
			if !shouldRemove {
				argStrings = append(argStrings, arg.Arg)
			}
		}

		// Append new args
		argStrings = append(argStrings, newArgs...)

		updatedCmdline := GrubArgsToString(argStrings)

		// Update kernel info
		kernelInfo[kernel] = UkiKernelInfo{
			Cmdline:   updatedCmdline,
			Initramfs: info.Initramfs,
		}
	}

	err = writeUkiKernelInfoFile(b.ukiKernelInfoPath, kernelInfo)
	if err != nil {
		return fmt.Errorf("failed to write UKI kernel info file:\n%w", err)
	}

	return nil
}
