// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

package imagecustomizerlib

import (
	"fmt"
	"io/fs"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	"github.com/microsoft/azurelinux/toolkit/tools/imagecustomizerapi"
	"github.com/microsoft/azurelinux/toolkit/tools/internal/file"
	"github.com/microsoft/azurelinux/toolkit/tools/internal/logger"
	"github.com/microsoft/azurelinux/toolkit/tools/internal/safechroot"
)

const (
	// location on output iso where some of the input mic configuration will be
	// saved for future iso-to-iso customizations.
	savedConfigsDir = "azl-image-customizer"

	// file holding the iso kernel parameters from the input mic configuration
	// to be re-appended/merged with newer configures for future iso-to-iso
	// customizations.
	savedConfigsFileName     = "saved-configs.yaml"
	savedConfigsFileNamePath = "/" + savedConfigsDir + "/" + savedConfigsFileName
)

type IsoInfoStore struct {
	kernelVersion            string
	seLinuxMode              imagecustomizerapi.SELinuxMode
	dracutPackageInfo        *PackageVersionInformation
	selinuxPolicyPackageInfo *PackageVersionInformation
}

type IsoFilesStore struct {
	artifactsDir         string
	bootEfiPath          string
	grubEfiPath          string
	isoBootImagePath     string
	isoGrubCfgPath       string
	pxeGrubCfgPath       string
	savedConfigsFilePath string
	vmlinuzPath          string
	initrdImagePath      string
	squashfsImagePath    string
	additionalFiles      map[string]string // local-build-path -> iso-media-path
}

// `IsoArtifacts` holds the extracted/generated artifacts necessary to build
// a LiveOS ISO image.
type IsoArtifactsStore struct {
	info  *IsoInfoStore
	files *IsoFilesStore
}

func (b *IsoArtifactsStore) cleanUp() error {
	if b.files != nil {
		err := os.RemoveAll(b.files.artifactsDir)
		if err != nil {
			return fmt.Errorf("failed to clean-up (%s):\n%w", b.files.artifactsDir, err)
		}
	}
	return nil
}

func containsGrubNoPrefix(filePaths []string) (bool, error) {
	_, bootFilesConfig, err := getBootArchConfig()
	if err != nil {
		return false, err
	}
	for _, filePath := range filePaths {

		if filepath.Base(filePath) == bootFilesConfig.grubNoPrefixBinary {
			return true, nil
		}

	}
	return false, nil
}

func findKernelVersion(imageRootDir string) (kernelVersion string, err error) {
	const kernelModulesDir = "/usr/lib/modules"

	kernelParentPath := filepath.Join(imageRootDir, kernelModulesDir)
	kernelDirs, err := os.ReadDir(kernelParentPath)
	if err != nil {
		return "", fmt.Errorf("failed to enumerate kernels under (%s):\n%w", kernelParentPath, err)
	}

	// Filter out directories that are empty.
	// Some versions of Azure Linux 2.0 don't cleanup properly when the kernel package is uninstalled.
	filteredKernelDirs := []fs.DirEntry(nil)
	for _, kernelDir := range kernelDirs {
		kernelPath := filepath.Join(kernelParentPath, kernelDir.Name())
		empty, err := file.IsDirEmpty(kernelPath)
		if err != nil {
			return "", err
		}

		if !empty {
			filteredKernelDirs = append(filteredKernelDirs, kernelDir)
		}
	}

	if len(filteredKernelDirs) == 0 {
		return "", fmt.Errorf("did not find any kernels installed under (%s)", kernelModulesDir)
	}
	if len(filteredKernelDirs) > 1 {
		return "", fmt.Errorf("unsupported scenario: found more than one kernel under (%s)", kernelModulesDir)
	}
	kernelVersion = filteredKernelDirs[0].Name()
	logger.Log.Debugf("Found installed kernel version (%s)", kernelVersion)
	return kernelVersion, nil
}

func getSELinuxMode(imageChroot *safechroot.Chroot) (imagecustomizerapi.SELinuxMode, error) {
	bootCustomizer, err := NewBootCustomizer(imageChroot)
	if err != nil {
		return imagecustomizerapi.SELinuxModeDefault, err
	}

	imageSELinuxMode, err := bootCustomizer.GetSELinuxMode(imageChroot)
	if err != nil {
		return imagecustomizerapi.SELinuxModeDefault, fmt.Errorf("failed to get current SELinux mode:\n%w", err)
	}

	return imageSELinuxMode, nil
}

func createIsoFilesStoreFromMountedImage(inputArtifactsStore *IsoArtifactsStore, imageRootDir string, storeDir string) (filesStore *IsoFilesStore, err error) {
	artifactsDir := filepath.Join(storeDir, "artifacts")

	filesStore = &IsoFilesStore{
		artifactsDir:         artifactsDir,
		savedConfigsFilePath: filepath.Join(artifactsDir, savedConfigsDir, savedConfigsFileName),
		additionalFiles:      make(map[string]string),
	}

	// the following files will be re-created - no need to copy them only to
	// have them overwritten.
	var exclusions []*regexp.Regexp
	//
	// We will generate a new initrd later. So, we do not copy the initrd.img
	// that comes in the input full disk image.
	//
	exclusions = append(exclusions, regexp.MustCompile(`/boot/initrd\.img.*`))
	exclusions = append(exclusions, regexp.MustCompile(`/boot/initramfs-.*\.img.*`))
	//
	// On full disk images (generated by Mariner toolkit), there are two
	// grub.cfg files:
	// - <boot partition>/boot/grub2/grub.cfg:
	//   - mounted at /boot/efi/boot/grub2/grub.cfg.
	//   - empty except for redirection to the other grub.cfg.
	// - <rootfs partition>/boot/grub2/grub.cfg:
	//   - mounted at /boot/grub2/grub.cfg
	//   - has the actual grub configuration.
	//
	// When creating an iso image out of a full disk image, we do not need the
	// redirection mechanism, and hence we can do with only the full grub.cfg.
	//
	// To avoid confusion, we do not copy the redirection grub.cfg to the iso
	// media.
	//
	exclusions = append(exclusions, regexp.MustCompile(`/boot/efi/boot/grub2/grub\.cfg`))

	bootFolderFilePaths, err := file.EnumerateDirFiles(filepath.Join(imageRootDir, "/boot"))
	if err != nil {
		return nil, fmt.Errorf("failed to scan /boot folder:\n%w", err)
	}

	usingGrubNoPrefix, err := containsGrubNoPrefix(bootFolderFilePaths)
	if err != nil {
		return nil, err
	}

	for _, sourcePath := range bootFolderFilePaths {

		excluded := false
		for _, exclusion := range exclusions {
			match := exclusion.FindStringIndex(sourcePath)
			if match != nil {
				excluded = true
				break
			}
		}
		if excluded {
			logger.Log.Debugf("Not copying %s. File is either unnecessary or will be re-generated.", sourcePath)
			continue
		}

		relativeFilePath := strings.TrimPrefix(sourcePath, imageRootDir)
		targetPath := strings.Replace(sourcePath, imageRootDir, filesStore.artifactsDir, -1)

		scheduleAdditionalFile := true

		_, bootFilesConfig, err := getBootArchConfig()
		if err != nil {
			return nil, err
		}
		osEspBootBinaryPath := bootFilesConfig.osEspBootBinaryPath
		osEspGrubBinaryPath := bootFilesConfig.osEspGrubBinaryPath
		osEspGrubNoPrefixBinaryPath := bootFilesConfig.osEspGrubNoPrefixBinaryPath

		switch relativeFilePath {
		case osEspBootBinaryPath:
			filesStore.bootEfiPath = targetPath
			scheduleAdditionalFile = false // No additional file scheduling

		case osEspGrubBinaryPath, osEspGrubNoPrefixBinaryPath:
			filesStore.grubEfiPath = targetPath
			scheduleAdditionalFile = false // No additional file scheduling

		case isoGrubCfgPath:
			if usingGrubNoPrefix {
				// When using the grubx64-noprefix.efi, the 'prefix' grub
				// variable is set to an empty string. When 'prefix' is an
				// empty string, and grubx64-noprefix.efi is run from an iso
				// media, the bootloader defaults to looking for grub.cfg at
				// <boot-media>/EFI/BOOT/grub.cfg.
				// So, below, we ensure that grub.cfg file will be placed where
				// grubx64-nopreifx.efi will be looking for it.
				//
				// Note that this grub.cfg is the only file that needs to be
				// copied to that EFI/BOOT location. The rest of the files (like
				// grubenv, etc) can be left under /boot as usual. This is
				// because grub.cfg still defines 'bootprefix' to be /boot.
				// So, once grubx64.efi loads EFI/BOOT/grub.cfg, it will set
				// bootprefix to the usual location boot/grub2 and will proceed
				// as usual from there.
				targetPath = filepath.Join(filesStore.artifactsDir, "EFI/BOOT", isoGrubCfg)
			}
			filesStore.isoGrubCfgPath = targetPath
			// We will place the pxe grub config next to the iso grub config.
			filesStore.pxeGrubCfgPath = filepath.Join(filepath.Dir(filesStore.isoGrubCfgPath), pxeGrubCfg)
			scheduleAdditionalFile = false
		}

		if strings.HasPrefix(filepath.Base(targetPath), vmLinuzPrefix) {
			targetPath = filepath.Join(filepath.Dir(targetPath), "vmlinuz")
			filesStore.vmlinuzPath = targetPath
			scheduleAdditionalFile = false
		}

		err = file.NewFileCopyBuilder(sourcePath, targetPath).
			SetNoDereference().
			Run()
		if err != nil {
			return nil, fmt.Errorf("failed to extract files from under the boot folder:\n%w", err)
		}

		if scheduleAdditionalFile {
			filesStore.additionalFiles[targetPath] = strings.TrimPrefix(targetPath, filesStore.artifactsDir)
		}
	}

	if inputArtifactsStore != nil && inputArtifactsStore.files != nil {

		// Copy the saved config files from the input iso store
		inputSavedConfigsFilePath := inputArtifactsStore.files.savedConfigsFilePath
		exists, err := file.PathExists(inputSavedConfigsFilePath)
		if err != nil {
			return nil, fmt.Errorf("failed to check if the saved config file (%s) exists in the input iso.\n%w", inputSavedConfigsFilePath, err)
		}
		if exists {
			err = file.Copy(inputSavedConfigsFilePath, filesStore.savedConfigsFilePath)
			if err != nil {
				return nil, fmt.Errorf("failed to copy save configuration file from (%s) to (%s):\n%w",
					inputSavedConfigsFilePath, filesStore.savedConfigsFilePath, err)
			}
		}

		// If we started from an input iso (not an input vhd(x)/qcow), then there
		// might be additional files that are not defined in the current user
		// configuration. Below, we loop through the files we have captured so far
		// and append any file that was in the input iso and is not included
		// already. This also ensures that no file from the input iso overwrites
		// a newer version that has just been created.

		// Copy the addition files from the input iso store
		for inputSourceFile, inputTargetFile := range inputArtifactsStore.files.additionalFiles {
			found := false
			for _, targetFile := range filesStore.additionalFiles {
				if inputTargetFile == targetFile {
					found = true
					break
				}
			}

			if !found {
				// Copy the file from the 'input' store to the 'current' store.
				relativeFilePath := strings.TrimPrefix(inputSourceFile, inputArtifactsStore.files.artifactsDir)
				currentSourceFile := filepath.Join(filesStore.artifactsDir, relativeFilePath)
				err = file.Copy(inputSourceFile, currentSourceFile)
				if err != nil {
					return nil, fmt.Errorf("failed to copy (%s) to (%s):\n%w", inputSourceFile, currentSourceFile, err)
				}

				// Update map
				filesStore.additionalFiles[currentSourceFile] = inputTargetFile
			}
		}
	}

	_, bootFilesConfig, err := getBootArchConfig()
	if err != nil {
		return nil, err
	}
	if filesStore.bootEfiPath == "" {
		return nil, fmt.Errorf("failed to find the boot efi file (%s):\n"+
			"this file is provided by the (shim) package",
			bootFilesConfig.bootBinary)
	}

	if filesStore.grubEfiPath == "" {
		return nil, fmt.Errorf("failed to find the grub efi file (%s or %s):\n"+
			"this file is provided by either the (grub2-efi-binary) or the (grub2-efi-binary-noprefix) package",
			bootFilesConfig.grubBinary, bootFilesConfig.grubNoPrefixBinary)
	}

	return filesStore, nil
}

func createIsoInfoStoreFromMountedImage(imageRootDir string) (infoStore *IsoInfoStore, err error) {
	infoStore = &IsoInfoStore{}

	kernelVersion, err := findKernelVersion(imageRootDir)
	if err != nil {
		return nil, fmt.Errorf("failed to determine kernel version from (%s):\n%w", imageRootDir, err)
	}
	infoStore.kernelVersion = kernelVersion

	chroot := safechroot.NewChroot(imageRootDir, true /*isExistingDir*/)
	if chroot == nil {
		return nil, fmt.Errorf("failed to create a new chroot object for (%s).", imageRootDir)
	}
	defer chroot.Close(true /*leaveOnDisk*/)

	err = chroot.Initialize("", nil, nil, true /*includeDefaultMounts*/)
	if err != nil {
		return nil, fmt.Errorf("failed to initialize chroot object for (%s):\n%w", imageRootDir, err)
	}

	imageSELinuxMode, err := getSELinuxMode(chroot)
	if err != nil {
		return nil, fmt.Errorf("failed to determine SELinux mode for (%s):\n%w", imageRootDir, err)
	}
	infoStore.seLinuxMode = imageSELinuxMode

	infoStore.dracutPackageInfo, err = getPackageInformation(chroot, "dracut")
	if err != nil {
		return nil, fmt.Errorf("failed to determine package information for dracut under (%s):\n%w", imageRootDir, err)
	}

	// Note the MIC allows the user to install other selinux policy packages.
	// So, the absence of selinux-policy does not mean that there are no selinux
	// policy packages.
	if isPackageInstalled(chroot, "selinux-policy") {
		infoStore.selinuxPolicyPackageInfo, err = getPackageInformation(chroot, "selinux-policy")
		if err != nil {
			return nil, fmt.Errorf("failed to determine package information for selinux-policy under (%s):\n%w", imageRootDir, err)
		}
	}

	return infoStore, nil
}

func createIsoFilesStoreFromIsoImage(isoImageFile, storeDir string) (filesStore *IsoFilesStore, err error) {
	artifactsDir := filepath.Join(storeDir, "artifacts")

	filesStore = &IsoFilesStore{
		artifactsDir:         artifactsDir,
		savedConfigsFilePath: filepath.Join(artifactsDir, savedConfigsDir, savedConfigsFileName),
	}

	err = extractIsoImageContents(storeDir, isoImageFile, filesStore.artifactsDir)
	if err != nil {
		return nil, fmt.Errorf("failed to extract iso contents from input iso file (%s):\n%w", isoImageFile, err)
	}

	isoFiles, err := file.EnumerateDirFiles(artifactsDir)
	if err != nil {
		return nil, fmt.Errorf("failed to enumerate expanded iso files under %s:\n%w", artifactsDir, err)
	}

	filesStore.additionalFiles = make(map[string]string)

	_, bootFilesConfig, err := getBootArchConfig()
	if err != nil {
		return nil, err
	}
	isoBootBinaryPath := bootFilesConfig.isoBootBinaryPath
	isoGrubBinaryPath := bootFilesConfig.isoGrubBinaryPath

	for _, isoFile := range isoFiles {
		relativeFilePath := strings.TrimPrefix(isoFile, artifactsDir)

		scheduleAdditionalFile := true

		switch relativeFilePath {
		case isoBootBinaryPath:
			filesStore.bootEfiPath = isoFile
			scheduleAdditionalFile = false
		case isoGrubBinaryPath:
			// Note that grubx64NoPrefixBinary is not expected to be present on
			// an existing iso - and hence we do not look for it here.
			// grubx64NoPrefixBinary may exist only on a vhdx/qcow when the
			// grub-noprefix package is installed. When such images are
			// converted to an iso, we rename the grub binary to its regular
			// name (grubx64.efi).
			filesStore.grubEfiPath = isoFile
			scheduleAdditionalFile = false
		case isoGrubCfgPath:
			filesStore.isoGrubCfgPath = isoFile
			// We will place the pxe grub config next to the iso grub config.
			filesStore.pxeGrubCfgPath = filepath.Join(filepath.Dir(filesStore.isoGrubCfgPath), pxeGrubCfg)
			scheduleAdditionalFile = false
		case liveOSImagePath:
			filesStore.squashfsImagePath = isoFile
			// the squashfs image file is added to the additional file list
			// by a different part of the code
			scheduleAdditionalFile = false
		case isoInitrdPath:
			filesStore.initrdImagePath = isoFile
			scheduleAdditionalFile = false
		case savedConfigsFileNamePath:
			filesStore.savedConfigsFilePath = isoFile
			scheduleAdditionalFile = false
		case isoKernelPath:
			filesStore.vmlinuzPath = isoFile
			scheduleAdditionalFile = false
		case isoBootImagePath:
			filesStore.isoBootImagePath = isoFile
			scheduleAdditionalFile = false
		}

		if scheduleAdditionalFile {
			filesStore.additionalFiles[isoFile] = strings.TrimPrefix(isoFile, artifactsDir)
		}
	}

	return filesStore, nil
}

func createIsoInfoStoreFromIsoImage(savedConfigFile string) (infoStore *IsoInfoStore, err error) {
	savedConfigs, err := loadSavedConfigs(savedConfigFile)
	if err != nil {
		return nil, fmt.Errorf("failed to load saved configurations (%s):\n%w", savedConfigFile, err)
	}

	infoStore = &IsoInfoStore{}

	// Need to populate the dracut package information from the saved copy
	// since we will not expand the rootfs and inspect its contents to get
	// such information.
	infoStore = &IsoInfoStore{
		dracutPackageInfo:        savedConfigs.OS.DracutPackageInfo,
		selinuxPolicyPackageInfo: savedConfigs.OS.SELinuxPolicyPackageInfo,
	}

	return infoStore, nil
}

func createIsoArtifactStoreFromMountedImage(inputArtifactsStore *IsoArtifactsStore, imageRootDir string, storeDir string) (artifactStore *IsoArtifactsStore, err error) {
	logger.Log.Debugf("Creating ISO store (%s)", storeDir)

	err = os.MkdirAll(storeDir, os.ModePerm)
	if err != nil {
		return nil, fmt.Errorf("failed to create folder %s:\n%w", storeDir, err)
	}

	artifactStore = &IsoArtifactsStore{}

	filesStore, err := createIsoFilesStoreFromMountedImage(inputArtifactsStore, imageRootDir, storeDir)
	if err != nil {
		return nil, err
	}
	artifactStore.files = filesStore

	infoStore, err := createIsoInfoStoreFromMountedImage(imageRootDir)
	if err != nil {
		return nil, err
	}
	artifactStore.info = infoStore

	return artifactStore, nil
}

func createIsoArtifactStoreFromIsoImage(isoImageFile, storeDir string) (artifactStore *IsoArtifactsStore, err error) {
	logger.Log.Debugf("Creating ISO store (%s)", storeDir)

	err = os.MkdirAll(storeDir, os.ModePerm)
	if err != nil {
		return nil, fmt.Errorf("failed to create folder %s:\n%w", storeDir, err)
	}

	artifactStore = &IsoArtifactsStore{}

	filesStore, err := createIsoFilesStoreFromIsoImage(isoImageFile, storeDir)
	if err != nil {
		return nil, err
	}
	artifactStore.files = filesStore

	infoStore, err := createIsoInfoStoreFromIsoImage(filesStore.savedConfigsFilePath)
	if err != nil {
		return nil, err
	}
	artifactStore.info = infoStore

	return artifactStore, nil
}

func fileExistsToString(filePath string) string {
	exists, err := file.PathExists(filePath)
	if err != nil {
		return fmt.Sprintf("%s (failed to check file):%s", filePath, err.Error())
	}
	if exists {
		return " e " + filePath
	}
	return "!e " + filePath
}

func dumpFilesStore(filesStore *IsoFilesStore) {
	logger.Log.Debugf("Files Store")
	if filesStore == nil {
		logger.Log.Debugf("-- not defined")
		return
	}
	logger.Log.Debugf("-- artifactsDir             = %s", fileExistsToString(filesStore.artifactsDir))
	logger.Log.Debugf("-- bootEfiPath              = %s", fileExistsToString(filesStore.bootEfiPath))
	logger.Log.Debugf("-- grubEfiPath              = %s", fileExistsToString(filesStore.grubEfiPath))
	logger.Log.Debugf("-- isoBootImagePath         = %s", fileExistsToString(filesStore.isoBootImagePath))
	logger.Log.Debugf("-- isoGrubCfgPath           = %s", fileExistsToString(filesStore.isoGrubCfgPath))
	logger.Log.Debugf("-- pxeGrubCfgPath           = %s", fileExistsToString(filesStore.pxeGrubCfgPath))
	logger.Log.Debugf("-- savedConfigsFilePath     = %s", fileExistsToString(filesStore.savedConfigsFilePath))
	logger.Log.Debugf("-- vmlinuzPath              = %s", fileExistsToString(filesStore.vmlinuzPath))
	logger.Log.Debugf("-- initrdImagePath          = %s", fileExistsToString(filesStore.initrdImagePath))
	logger.Log.Debugf("-- squashfsImagePath        = %s", fileExistsToString(filesStore.squashfsImagePath))
	logger.Log.Debugf("-- additionalFiles          =")
	for key, value := range filesStore.additionalFiles {
		logger.Log.Debugf("-- -- localPath: %s, isoPath: %s\n", fileExistsToString(key), value)
	}
}

func dumpInfoStore(infoStore *IsoInfoStore) {
	logger.Log.Debugf("Info Store")
	if infoStore == nil {
		logger.Log.Debugf("-- not defined")
		return
	}
	logger.Log.Debugf("-- kernelVersion        = %s", infoStore.kernelVersion)
	logger.Log.Debugf("-- seLinuxMode          = %s", infoStore.seLinuxMode)
	if infoStore.dracutPackageInfo != nil {
		logger.Log.Debugf("-- dracut package info  = %s", infoStore.dracutPackageInfo.getFullVersionString())
	} else {
		logger.Log.Debugf("-- dracut package info  = unavailable")
	}
	if infoStore.selinuxPolicyPackageInfo != nil {
		logger.Log.Debugf("-- selinux package info = %s", infoStore.selinuxPolicyPackageInfo.getFullVersionString())
	} else {
		logger.Log.Debugf("-- selinux package info = unavailable")
	}
}

func dumpArtifactsStore(artifactStore *IsoArtifactsStore, title string) {
	logger.Log.Debugf("Artifacts Store - %s", title)
	if artifactStore == nil {
		logger.Log.Debugf("-- not defined")
		return
	}
	dumpFilesStore(artifactStore.files)
	dumpInfoStore(artifactStore.info)
}
